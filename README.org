#+TITLE: SharpDeceiver: C# 语义误导混淆器
#+AUTHOR: 开发团队
#+OPTIONS: toc:2

* 项目简介
SharpDeceiver 是一个专门为 C# 设计的源代码级混淆工具. 与传统的乱码混淆不同, 它生成的代码在视觉上" 看起来很有意义" , 但实际逻辑语义完全对不上, 从而通过伪装手段大幅提高人类开发者和 AI 编程助手(如 Copilot, Cursor)的理解成本.

本工具支持**原地混淆**与**原地恢复**, 确保开发流程的无缝衔接.

* 核心特性

* **语义伪装 (Semantic Camouflage)**: 弃用 =a1_b2= 这种明显的随机字符, 转而使用诸如 =BaseMonitor=, =StreamHelper=, =ContextProcessor= 等看起来极其正规但与原意无关的词汇.
* **原地替换 (In-place Transformation)**: 直接修改指定路径下的源文件, 无需维护镜像目录.
* **可逆操作 (Reversible)**: 通过本地生成的 =deceiver_map.json= 记录映射关系, 随时一键还原回原始代码.
* **项目过滤**: 可在处理过程中排除指定的工程(Project), 避免对公共库或测试代码进行干扰.
* **命令行驱动**: 适合集成到构建脚本中.

* 使用方法
本工具编译后生成 =SharpDeceiver.exe=.

**注意: 在进行混淆前, 强烈建议先提交 Git 仓库或备份代码. **

** 1. 混淆代码 (Obfuscate)
对指定路径下的代码进行原地重命名.
#+BEGIN_SRC bash
./SharpDeceiver.exe --mode obfuscate --path "C:/MyProject/Solution.sln" --exclude "CommonLib,UnitTests"
#+END_SRC

* 此操作会修改所有相关 =.cs= 文件.
* 同时在根目录生成 =deceiver_map.json=.

** 2. 还原代码 (Restore)
利用映射文件将代码恢复到可读状态.
#+BEGIN_SRC bash
./SharpDeceiver.exe --mode restore --path "C:/MyProject/Solution.sln" --map "./deceiver_map.json"
#+END_SRC

* 参数详解
| 长参数       | 短参数 | 描述                                              |
|--------------+--------+---------------------------------------------------|
| --mode       | -m     | 运行模式: =obfuscate= (混淆) 或 =restore= (还原)    |
| --path       | -p     | 目标 C# 解决方案 (.sln) 或项目目录路径            |
| --exclude    | -e     | 排除的项目名称列表, 以逗号分隔                    |
| --map        | -s     | 映射文件保存/读取路径 (默认: ./deceiver_map.json) |
| --dictionary | -d     | (可选) 自定义误导性词库文件路径                   |
* 混淆示例
** 原始代码 (Original)
#+BEGIN_SRC csharp
public class UserAuthService {
public bool Login(string password) {
return password == "123456";
}
}
#+END_SRC

** 混淆后代码 (Deceived)
#+BEGIN_SRC csharp
// 代码语义看起来像是数据缓存处理, 实际是登录逻辑
public class CacheBufferProvider {
public bool sync_metadata(string input_buffer) {
return input_buffer == "123456";
}
}
#+END_SRC

* 技术架构

1. **基于 Roslyn 分析**: 使用 =Microsoft.CodeAnalysis= 深度解析 C# 语法树 (AST) 和符号信息.
2. **误导性词库**: 预置了约 1000 个常见的软件工程词汇, 混淆时会从词库中随机抽取并组合, 确保混淆后的标识符" 看起来很像真的" .
3. **符号重命名**: 使用 =Renamer.RenameSymbolAsync= 确保所有引用(调用处, 定义处)同步修改, 不破坏代码的编译正确性.

* 许可证
MIT Licensex
